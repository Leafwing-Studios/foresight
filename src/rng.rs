//! Generates random numbers and stores them as resources

use std::fmt::Display;

use arraydeque::ArrayDeque;
use bevy::prelude::*;

/// Initializes resources for RNG state and values
pub struct RNGPlugin;

impl Plugin for RNGPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<Rng>().init_resource::<RNGOutputs>();
    }
}

/// A dead simple RNG function that generates a sequence of u8 values
/// Repeats after approximately 17000 steps
///
/// Based on the SMW RNG function
#[derive(Debug, Clone, PartialEq)]
pub struct Rng {
    s: u8,
    t: u8,
}

impl Rng {
    /// Create a new RNG with the given internal state
    #[must_use]
    pub fn new(s: u8, t: u8) -> Self {
        Rng { s, t }
    }

    /// Generates a new random number between 0 and 255
    #[must_use]
    pub fn gen(&mut self) -> u8 {
        self.step();
        self.s ^ self.t
    }

    /// Generates a new random number between 0 and 255, also outputting the internal RNG state that led to that result
    pub fn gen_verbose(&mut self) -> RNGInternals {
        let result = self.gen();
        return RNGInternals {
            s: self.s,
            t: self.t,
            result,
        };
    }

    /// Advances the RNG once
    fn step(&mut self) {
        self.s = self.s.wrapping_mul(5).wrapping_add(1);
        self.t = self.t.wrapping_mul(2);

        if Self::get_bit_at(self.t, 4) == Self::get_bit_at(self.t, 7) {
            self.t = self.t.wrapping_add(1);
        }
    }

    fn get_bit_at(input: u8, n: u8) -> bool {
        if n < 8 {
            input & (1 << n) != 0
        } else {
            false
        }
    }
}

impl Default for Rng {
    fn default() -> Self {
        // In general, it is bad to always initialize your RNG function to the same value
        // But this isn't supposed to be a good RNG function >:3
        Self::new(42, 69)
    }
}

/// A struct that bundles an RNG result with the two internal RNG state values that generated it. Because of how the RNG function works, `result` will always be equal to `s ^ t`.
pub struct RNGInternals {
    /// First internal value of the RNG function
    pub s: u8,
    /// Second internal value of the RNG function
    pub t: u8,
    /// The random value generated by the RNG function call
    pub result: u8,
}

impl Display for RNGInternals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!(
            "{:03}, {:03}: {:03}",
            self.s, self.t, self.result
        ))
    }
}

/// Size of the ring buffer for RNG values. This includes the "up next" RNG value, the lookahead values, and the previous values
pub const RNG_BUFFER_SIZE: usize = 21;
/// THe index of the "next" RNG value to use. This always constant, as the lookahead and lookbehind should not change throughout gameplay
pub const CURRENT_RNG_VALUE_INDEX: usize = 10;

/// Ring buffer of current, past, and upcoming RNG values
/// The total size of the buffer is given by [`RNG_BUFFER_SIZE`], and the "next to be used" rng value is given by [`CURRENT_RNG_VALUE_INDEX`]
pub struct RNGOutputs(pub ArrayDeque<[RNGInternals; RNG_BUFFER_SIZE]>);

impl FromWorld for RNGOutputs {
    fn from_world(world: &mut World) -> Self {
        let mut rng = world.get_resource_mut::<Rng>().unwrap();
        let mut buffer = RNGOutputs(ArrayDeque::new());

        for _ in 0..RNG_BUFFER_SIZE {
            let result = rng.gen_verbose();
            buffer.0.push_back(result).unwrap();
        }

        buffer
    }
}

/// Gets the "up next" RNG value from the ring buffer, then generates a new value to replace it
pub fn get_next_rng_value(rng: &mut Rng, buffer: &mut RNGOutputs) -> u8 {
    let val = buffer.0[CURRENT_RNG_VALUE_INDEX].result;
    buffer.0.pop_front();
    buffer.0.push_back(rng.gen_verbose()).unwrap();

    val
}
